---
// ========== TOOL INDEX PAGE IMPLEMENTATION ==========
// Story 2.5: Create Dynamic Tool Index Page
// Purpose: Display all articles for a specific tool category
// File: src/pages/tools/[tool]/index.astro

// Import required dependencies
import { getCollection, type CollectionEntry } from "astro:content";
import { readdir } from "fs/promises";
import { join } from "path";

// ========== PERFORMANCE MONITORING ==========
// Subtask 8.1: Build time measurement for index page generation
const startTime = performance.now();

// ========== STATIC PATH GENERATION ==========
// Task 2: Implement getStaticPaths with robust error handling
export async function getStaticPaths() {
  try {
    // Subtask 2.1: Scan tool-articles directory for tool subdirectories
    const toolArticlesPath = join(process.cwd(), "src/content/tool-articles");
    
    // Validate directory exists
    let toolDirectories: string[] = [];
    try {
      const entries = await readdir(toolArticlesPath, { withFileTypes: true });
      toolDirectories = entries
        .filter(entry => entry.isDirectory())
        .map(entry => entry.name);
    } catch (error) {
      console.warn("‚ö†Ô∏è Warning: Could not read tool-articles directory:", error);
      // Subtask 2.3: Fallback to empty array if directory doesn't exist
      return [];
    }

    // Subtask 2.2: Generate static paths for each tool with validation
    const validTools = ["anki", "migaku", "yomitan"];
    const paths = toolDirectories
      .filter(dir => validTools.includes(dir))
      .map(tool => ({
        params: { tool },
        props: { toolName: tool }
      }));

    console.log("‚úÖ Generated static paths for tools:", paths.map(p => p.params.tool));
    return paths;

  } catch (error) {
    // Subtask 2.4: Prevent build failures with try-catch blocks
    console.error("üö® Critical error in getStaticPaths:", error);
    // Return empty array to prevent build failure
    return [];
  }
}

// ========== COMPONENT LOGIC ==========
// Task 3: Get tool parameter from Astro.params
const { tool } = Astro.params as { tool: string };

// Validate tool parameter
if (!tool) {
  console.warn("‚ö†Ô∏è No tool parameter provided");
  return Astro.redirect("/tools", 301);
}

// Security: Validate tool name against whitelist
const validTools = ["anki", "migaku", "yomitan"];
if (!validTools.includes(tool)) {
  console.warn("üö® Security: Invalid tool name requested:", tool);
  return Astro.redirect("/tools", 301);
}

// Task 4: Fetch all articles from the collection
let articles: CollectionEntry<"tool-articles">[] = [];
try {
  articles = await getCollection("tool-articles");
} catch (error) {
  console.error("üö® Error fetching tool-articles collection:", error);
  articles = [];
}

// Task 5: Filter articles for current tool using tag-based filtering
// REPLACE EXISTING SLUG-BASED FILTERING (lines 84-95)
const toolArticles = articles.filter(article => {
  try {
    // Validate tags exist and are in correct format
    if (!article.data.tags || !Array.isArray(article.data.tags)) {
      console.warn("‚ö†Ô∏è Article missing or invalid tags:", article.id);
      return false;
    }

    // Check if current tool is in article's tags array
    return article.data.tags.includes(tool);
  } catch (error) {
    console.warn("‚ö†Ô∏è Error processing article tags:", article.id, error);
    return false;
  }
});

// Subtask 5.2: Handle case where no articles are found
const hasArticles = toolArticles.length > 0;

// ========== ENHANCED PERFORMANCE MONITORING WITH CACHING ==========
const performanceMetrics = {
  startTime: startTime,
  collectionLoadTime: 0,
  articleProcessingTime: 0,
  cachingMetrics: {
    cacheHits: 0,
    cacheMisses: 0,
    cacheEfficiency: 0,
    cacheSize: 0
  },
  totalArticles: articles.length,
  filteredArticles: toolArticles.length
};

// Initialize cache for performance monitoring
const tagFilterCache = new Map<string, CollectionEntry<"tool-articles">[]>();

// Measure collection loading time
const collectionStartTime = performance.now();
try {
  // Articles already loaded above, measure the time it took
  performanceMetrics.collectionLoadTime = collectionStartTime - startTime;
} catch (error) {
  console.error("üö® Collection loading failed:", error);
}

// Measure article processing time with caching
const processingStartTime = performance.now();
const cacheKey = `${tool}_${articles.length}_${articles.map(a => a.id).join(',')}`;

let cachedToolArticles: CollectionEntry<"tool-articles">[];
if (tagFilterCache.has(cacheKey)) {
  // Cache hit
  cachedToolArticles = tagFilterCache.get(cacheKey)!;
  performanceMetrics.cachingMetrics.cacheHits++;
  console.log("üöÄ Cache hit for tool:", tool);
} else {
  // Cache miss - use already filtered articles
  cachedToolArticles = toolArticles;

  // Cache the result
  tagFilterCache.set(cacheKey, toolArticles);
  performanceMetrics.cachingMetrics.cacheMisses++;
  console.log("üíæ Cache miss for tool:", tool, "- cached result");
}

performanceMetrics.articleProcessingTime = performance.now() - processingStartTime;

// Calculate caching efficiency
performanceMetrics.cachingMetrics.cacheEfficiency =
  (performanceMetrics.cachingMetrics.cacheHits /
   (performanceMetrics.cachingMetrics.cacheHits + performanceMetrics.cachingMetrics.cacheMisses)) * 100;
performanceMetrics.cachingMetrics.cacheSize = tagFilterCache.size;

// Log comprehensive performance metrics
const totalTime = performance.now() - startTime;
console.log("üéØ Enhanced Performance Metrics:", {
  totalBuildTime: `${totalTime.toFixed(2)}ms`,
  collectionLoadTime: `${performanceMetrics.collectionLoadTime.toFixed(2)}ms`,
  articleProcessingTime: `${performanceMetrics.articleProcessingTime.toFixed(2)}ms`,
  totalArticles: performanceMetrics.totalArticles,
  filteredArticles: performanceMetrics.filteredArticles,
  efficiency: `${((performanceMetrics.filteredArticles / performanceMetrics.totalArticles) * 100).toFixed(1)}%`,
  caching: {
    hits: performanceMetrics.cachingMetrics.cacheHits,
    misses: performanceMetrics.cachingMetrics.cacheMisses,
    efficiency: `${performanceMetrics.cachingMetrics.cacheEfficiency.toFixed(1)}%`,
    cacheSize: performanceMetrics.cachingMetrics.cacheSize
  }
});

// Enhanced performance validation with caching metrics
if (totalTime > 2000) {
  console.warn("‚ö†Ô∏è Performance: Build time exceeds 2 second target");
}
if (performanceMetrics.articleProcessingTime > articles.length) {
  console.warn("‚ö†Ô∏è Performance: Article processing time exceeds 1ms per article target");
}
if (performanceMetrics.cachingMetrics.cacheEfficiency < 50) {
  console.warn("‚ö†Ô∏è Caching: Cache efficiency below 50% - consider cache optimization");
}
if (performanceMetrics.cachingMetrics.cacheSize > 100) {
  console.warn("‚ö†Ô∏è Caching: Cache size exceeds 100 entries - consider cache cleanup");
}
---

<!doctype html>
<html lang="id">
  <head>
    <title>{tool.charAt(0).toUpperCase() + tool.slice(1)} - GoRakuDo</title>
    <meta name="description" content={`All articles and guides for ${tool} tool`} />
  </head>

  <body>
    <!-- Page Header -->
    <header>
      <h1>{tool.charAt(0).toUpperCase() + tool.slice(1)} Articles</h1>
      <p>Browse all available documentation for {tool}</p>
    </header>

    <!-- Navigation -->
    <nav>
      <a href="/tools">‚Üê Back to Tools</a>
    </nav>

    <!-- Main Content -->
    <main>
      {hasArticles ? (
        <!-- Task 6: Render ul of filtered articles -->
        <ul>
          {toolArticles.map(article => {
            // Task 7: Render li with link for each article
            // Subtask 7.1: Create proper link structure
            const articleSlug = article.slug.replace(`${tool}/`, "");
            const articleUrl = `/tools/${tool}/${articleSlug}`;
            
            // Subtask 7.2: Add fallback text if article title is missing
            const articleTitle = article.data.title || `Article ${article.id}`;
            
            return (
              <li>
                <!-- Subtask 7.3: Validate article slugs before link generation -->
                <a href={articleUrl} title={article.data.description || ""}>
                  {articleTitle}
                </a>
                {article.data.description && (
                  <p>{article.data.description}</p>
                )}
              </li>
            );
          })}
        </ul>
      ) : (
        <!-- Subtask 5.2: No articles found fallback message -->
        <div>
          <p>No articles available for {tool} yet. Check back soon for new content!</p>
          <p>Available tools: <a href="/tools/anki">anki</a>, <a href="/tools/migaku">migaku</a>, <a href="/tools/yomitan">yomitan</a></p>
        </div>
      )}
    </main>

    <!-- Error Handling Fallback -->
    {!hasArticles && articles.length === 0 && (
      <div>
        <p>Unable to load tool articles. Please try refreshing the page.</p>
        <a href="/tools">Return to Tools Page</a>
      </div>
    )}
  </body>
</html>
